const e=(t,s,r,n=null)=>{let a,i,o,l=0,p=r.length,u=s.length,{remove:h,same:c,insert:d,replace:f}=e;for(;l<p&&l<u&&c(s[l],r[l]);)l++;for(;l<p&&l<u&&c(r[p-1],s[u-1]);)n=r[(--u,--p)];if(l==u)for(;l<p;)d(n,r[l++],t);else{for(a=s[l];l<p;)o=r[l++],i=a?a.nextSibling:n,c(a,o)?a=i:l<p&&c(r[l],i)?(f(a,o,t),a=i):d(a,o,t);for(;!c(a,n);)i=a.nextSibling,h(a,t),a=i}return r};e.same=(e,t)=>e==t,e.replace=(e,t,s)=>s.replaceChild(t,e),e.insert=(e,t,s)=>s.insertBefore(t,e),e.remove=(e,t)=>t.removeChild(e);const t={processCallback(e,t,s){if(s)for(const e of t)if(e.expression in s){const t=s[e.expression];"boolean"==typeof t&&e instanceof n&&"boolean"==typeof e.element[e.attributeName]?e.booleanValue=t:"function"==typeof t&&e instanceof n?e.element[e.attributeName]=t:e.value=t}}};class s extends DocumentFragment{#e;#t;constructor(e,s,r=t){super(),this.appendChild(e.content.cloneNode(!0)),this.#e=o(this),this.#t=r,s||={},r.createCallback?.(this,this.#e,s),r.processCallback(this,this.#e,s)}update(e){this.#t.processCallback(this,this.#e,e)}}class r{constructor(e,t){this.setter=e,this.expression=t}toString(){return this.value}}class n extends r{#s="";get attributeName(){return this.setter.attr.name}get attributeNamespace(){return this.setter.attr.namespaceURI}get element(){return this.setter.element}get value(){return this.#s}set value(e){if(this.#s===e)return;this.#s=e;const{attr:t,element:s,parts:r}=this.setter;1===r.length?null==e?s.removeAttributeNS(t.namespaceURI,t.name):s.setAttributeNS(t.namespaceURI,t.name,e):s.setAttributeNS(t.namespaceURI,t.name,r.join(""))}get booleanValue(){return this.setter.element.hasAttributeNS(this.attributeNamespace,this.setter.attr.name)}set booleanValue(e){if(1!==this.setter.parts.length)throw new DOMException("Value is not fully templatized");this.value=e?"":null}}class a extends r{#r=[new Text];get replacementNodes(){return this.#r}get parentNode(){return this.setter.parentNode}get nextSibling(){return this.#r[this.#r.length-1].nextSibling}get previousSibling(){return this.#r[0].previousSibling}get value(){return this.#r.map((e=>e.textContent)).join("")}set value(e){this.replace(e)}replace(...t){(t=t.flat().flatMap((e=>null==e?[new Text]:e.forEach?[...e]:11===e.nodeType?[...e.childNodes]:e.nodeType?[e]:[new Text(e)]))).length||t.push(new Text),this.#r=e(this.#r[0].parentNode,this.#r,t,this.nextSibling)}replaceHTML(e){const t=this.parentNode.cloneNode();t.innerHTML=e,this.replace(t.childNodes)}}class i extends a{directive;constructor(e,t){let s=t.getAttribute("directive")||t.getAttribute("type"),r=t.getAttribute("expression")||t.getAttribute(s)||"";r.startsWith("{{")&&(r=r.trim().slice(2,-2).trim()),super(e,r),this.template=t,this.directive=s}}const o=(e,t=[])=>{let s,r,p,h,c;for(s of e.attributes||[])if(s.value.includes("{{")){for([h,c]of(p={element:e,attr:s,parts:[]},l(s.value)))h?(c=new n(p,c),p.parts.push(c),t.push(c)):p.parts.push(c);s.value=p.parts.join("")}for(r of e.childNodes)if(1!==r.nodeType||r instanceof HTMLTemplateElement){if(1===r.nodeType&&u(r))o(r.content,t);else if(1===r.nodeType||r.data.includes("{{")){const s={parentNode:e,parts:[]};if(r.data)for([h,c]of l(r.data))h?(c=new a(s,c),s.parts.push(c),t.push(c)):s.parts.push(new Text(c));else c=new i(s,r),s.parts.push(c),t.push(c);r.replaceWith(...s.parts.flatMap((e=>e.replacementNodes||[e])))}}else o(r,t);return t},l=e=>{let t,s="",r=0,n=p[e],a=0;if(n)return n;for(n=[];t=e[a];a++)"{"===t&&"{"===e[a+1]&&"\\"!==e[a-1]&&e[a+2]&&1==++r?(s&&n.push([0,s]),s="",a++):"}"!==t||"}"!==e[a+1]||"\\"===e[a-1]||--r?s+=t||"":(n.push([1,s.trim()]),s="",a++);return s&&n.push([0,(r>0?"{{":"")+s]),p[e]=n},p={},u=e=>e instanceof HTMLTemplateElement&&!(e.hasAttribute("directive")||e.hasAttribute("type")||e.hasAttribute("expression"));export{n as AttributeTemplatePart,i as InnerTemplatePart,a as NodeTemplatePart,s as TemplateInstance,r as TemplatePart,t as defaultProcessor,o as parse,l as tokenize};
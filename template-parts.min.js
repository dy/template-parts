const e=(t,s,r,n=null)=>{let i,a,l,o=0,p=r.length,u=s.length,{remove:h,same:c,insert:d,replace:m}=e;for(;o<p&&o<u&&c(s[o],r[o]);)o++;for(;o<p&&o<u&&c(r[p-1],s[u-1]);)n=r[(--u,--p)];if(o==u)for(;o<p;)d(n,r[o++],t);else{for(i=s[o];o<p;)l=r[o++],a=i?i.nextSibling:n,c(i,l)?i=a:o<p&&c(r[o],a)?(m(i,l,t),i=a):d(i,l,t);for(;!c(i,n);)a=i.nextSibling,h(i,t),i=a}return r};e.same=(e,t)=>e==t,e.replace=(e,t,s)=>s.replaceChild(t,e),e.insert=(e,t,s)=>s.insertBefore(t,e),e.remove=(e,t)=>t.removeChild(e);const t={processCallback(e,t,s){if(s)for(const e of t)e.expression in s&&(e.value=s[e.expression])}};class s extends DocumentFragment{#e;#t;constructor(e,s,r=t){super(),this.appendChild(e.content.cloneNode(!0)),this.#e=l(this),this.#t=r,s||={},r.createCallback?.(this,this.#e,s),r.processCallback(this,this.#e,s)}update(e){this.#t.processCallback(this,this.#e,e)}}class r{constructor(e,t){this.setter=e,this.expression=t}toString(){return this.value}}class n extends r{#s="";get attributeName(){return this.setter.attr.name}get attributeNamespace(){return this.setter.attr.namespaceURI}get element(){return this.setter.element}get value(){return this.#s}set value(e){if(this.#s===e)return;this.#s=e;const{attr:t,element:s,parts:r}=this.setter;1===r.length?null==e?s.removeAttributeNS(t.namespaceURI,t.name):s.setAttributeNS(t.namespaceURI,t.name,e):s.setAttributeNS(t.namespaceURI,t.name,r.join(""))}get booleanValue(){this.setter.element.hasAttribute(this.setter.attr.name)}set booleanValue(e){if(1!==this.setter.parts.length)throw new DOMException("Value is not fully templatized");this.value=e?"":null}}class i extends r{#r=[new Text];get replacementNodes(){return this.#r}get parentNode(){return this.setter.parentNode}get nextSibling(){return this.#r[this.#r.length-1].nextSibling}get previousSibling(){return this.#r[0].previousSibling}get value(){return this.#r.map((e=>e.textContent)).join("")}set value(e){this.replace(e)}replace(...t){(t=t.flat().flatMap((e=>null==e?[new Text]:e.forEach?[...e]:11===e.nodeType?[...e.childNodes]:e.nodeType?[e]:[new Text(e)]))).length||t.push(new Text),this.#r=e(this.#r[0].parentNode,this.#r,t,this.nextSibling)}replaceHTML(e){const t=this.parentNode.cloneNode();t.innerHTML=e,this.replace(t.childNodes)}}class a extends i{directive;constructor(e,t){let s=t.getAttribute("directive")||t.getAttribute("type"),r=t.getAttribute("expression")||t.getAttribute(s)||"";r.startsWith("{{")&&(r=r.trim().slice(2,-2).trim()),super(e,r),this.template=t,this.directive=s}}const l=(e,t=[])=>{let s,r,p,u,h;for(s of e.attributes||[])if(s.value.includes("{{")){for([u,h]of(p={element:e,attr:s,parts:[]},o(s.value)))u?(h=new n(p,h),p.parts.push(h),t.push(h)):p.parts.push(h);s.value=p.parts.join("")}for(r of e.childNodes)if(1!==r.nodeType||r instanceof HTMLTemplateElement){if(1===r.nodeType||r.data.includes("{{")){const s={parentNode:e,parts:[]};if(r.data)for([u,h]of o(r.data))u?(h=new i(s,h),s.parts.push(h),t.push(h)):s.parts.push(new Text(h));else h=new a(s,r),s.parts.push(h),t.push(h);r.replaceWith(...s.parts.flatMap((e=>e.replacementNodes||[e])))}}else l(r,t);return t},o=e=>{let t,s="",r=0,n=p[e],i=0;if(n)return n;for(n=[];t=e[i];i++)"{"===t&&"{"===e[i+1]&&"\\"!==e[i-1]&&e[i+2]&&1==++r?(s&&n.push([0,s]),s="",i++):"}"!==t||"}"!==e[i+1]||"\\"===e[i-1]||--r?s+=e[i]||"":(n.push([1,s.trim()]),s="",i++);return s&&n.push([0,s]),p[e]=n},p={};export{n as AttributeTemplatePart,a as InnerTemplatePart,i as NodeTemplatePart,s as TemplateInstance,r as TemplatePart,t as defaultProcessor,l as parse,o as tokenize};